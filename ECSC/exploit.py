#!/usr/bin/env python3
from pwn import remote
from Crypto.Cipher import AES
import os, binascii, sys

HOST = "34.244.222.63"
PORT = 13301

def is_pseudorandom(resp_bytes, key):
    # resp_bytes length must be 32
    a = resp_bytes[:16]
    b = resp_bytes[16:32]
    aes = AES.new(key, AES.MODE_ECB)
    try:
        x = aes.decrypt(a)
        y = aes.encrypt(b)
        return x == y
    except Exception:
        return False

def play_once(r):
    # choose to ask a question
    r.sendline(b"3")
    # pick any 32-byte message (we'll use random)
    msg = os.urandom(32)
    hexmsg = binascii.hexlify(msg)
    r.recvuntil(b"State your question for the souls:")
    r.sendline(hexmsg)
    # parse the two responses
    r.recvuntil(b"The left soul screams: ")
    left_hex = r.recvline().strip()
    r.recvuntil(b"The right soul screams: ")
    right_hex = r.recvline().strip()

    left_bytes = binascii.unhexlify(left_hex)
    right_bytes = binascii.unhexlify(right_hex)

    left_is_pseudo = is_pseudorandom(left_bytes, msg)
    right_is_pseudo = is_pseudorandom(right_bytes, msg)

    # sanity:
    if left_is_pseudo == right_is_pseudo:
        # both same -> something unexpected; fail-safe: guess left false (shouldn't happen)
        choice = b"1"
    else:
        # true random is the one that is NOT pseudorandom
        if not left_is_pseudo:
            choice = b"1"
        else:
            choice = b"2"

    r.recvuntil(b"> ")
    r.sendline(choice)
    # Read the immediate reply (SUCCESS or FAIL)
    out = r.recvline(timeout=2)
    return out

def main():
    r = remote(HOST, PORT)
    # read banner and intro until first prompt
    r.recvuntil(b"> ")

    # The server gives you 50 souls to clear; loop until we get the flag or connection closes
    while True:
        # we will prefer to ask question each round and then choose.
        try:
            result = play_once(r)
        except Exception as e:
            print("Exception:", e)
            break

        if result is None:
            # maybe the server printed multiple lines; try to read more
            try:
                data = r.recv(timeout=1)
                print(data.decode(errors='ignore'))
            except:
                pass

        # If we reduced souls to 0 the server prints flag after the loop â€” read until EOF/flag
        # Look ahead for either fail, success, or final flag marker
        data = r.recv(timeout=1)
        if data:
            s = data.decode(errors='ignore')
            print(s, end="")
            # crude check for flag (adjust if flag format differs)
            if "flag" in s.lower() or "{" in s:
                # print remaining
                try:
                    rest = r.recv(timeout=2)
                    print(rest.decode(errors='ignore'))
                except:
                    pass
                break

    r.close()

if __name__ == "__main__":
    main()
